# windi_test_task
WinDi micro messager test task


## Setup

### Clone repository
```shell
git clone git@github.com:include5691/windi_test_task.git
cd windi_test_task
```

### Create and fulfill .env file

**Variables:**
- `SECRET_KEY`: jwt secret. You may generate it using:
```shell
openssl rand -base64 15
```
- `DATABASE_URL`: your postgres url. In this example: `postgresql+asyncpg://postgres:postgres@postgres/windi_db`
- `ALEMBIC_DATABASE_URL`: your postgres syncronous url. In this example: `postgresql://postgres:postgres@postgres/windi_db`

**Copy me**:
```
SECRET_KEY="VerySecretSecret"
DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres/windi_db
ALEMBIC_DATABASE_URL=postgresql://postgres:postgres@postgres/windi_db
```

### Check your local postgres server
```shell
sudo systemctl status postgresql
```
If active, disable it:
```shell
sudo systemctl stop postgresql
```

### Download, install docker and docker compose
[Install](https://docs.docker.com/engine/install/) docker engine

And docker compose plugin:
```shell
sudo apt install docker-compose-plugin
```

### Run docker copose
```shell
docker compose up --build
```

### Test data
Creates automatically during build

## Swagger UI
Swagger UI available after launch via url:  
http://127.0.0.1:8000/docs  



## API Examples

Base URL: `http://localhost:8000` (or your configured host/port)

**Note:** Replace `YOUR_ACCESS_TOKEN` with the actual token obtained from the `/token` endpoint. Replace placeholders like `{chat_id}`, `{user_id}` with actual IDs.

### Authentication

1.  **Register a new user:**
    ```bash
    curl -X POST "http://localhost:8000/register/" \
         -H "Content-Type: application/json" \
         -d '{
               "name": "Test User",
               "email": "test@example.com",
               "password": "yoursecurepassword"
             }'
    ```

2.  **Get access token:**
    ```bash
    curl -X POST "http://localhost:8000/token/" \
         -H "Content-Type: application/x-www-form-urlencoded" \
         -d "username=test@example.com&password=yoursecurepassword"
    ```
    *(Copy the `access_token` from the response for subsequent requests)*

### Chats

3.  **Get all chats for the current user:**
    ```bash
    curl -X GET "http://localhost:8000/chats/" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```

4.  **Create a new private chat:**
    ```bash
    curl -X POST "http://localhost:8000/chats/" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
         -H "Content-Type: application/json" \
         -d '{
               "is_group": false,
               "recipient_id": 2
             }'
    ```
    *(Requires the recipient user with ID 2 to exist)*

5.  **Create a new group chat:**
    ```bash
    curl -X POST "http://localhost:8000/chats/" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
         -H "Content-Type: application/json" \
         -d '{
               "name": "My Awesome Group",
               "is_group": true
             }'
    ```

6.  **Add a user to a group chat:**
    ```bash
    curl -X POST "http://localhost:8000/chats/{chat_id}/add-user?user_id={user_id}" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
    *(Replace `{chat_id}` with the group chat ID and `{user_id}` with the ID of the user to add)*

7.  **Exit a chat:**
    ```bash
    curl -X DELETE "http://localhost:8000/chats/{chat_id}/exit" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
    *(Replace `{chat_id}` with the ID of the chat to leave)*

### Messages

8.  **Get chat message history (with pagination):**
    ```bash
    curl -X GET "http://localhost:8000/history/{chat_id}?limit=50&offset=0" \
         -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
    ```
    *(Replace `{chat_id}` with the chat ID. Adjust `limit` and `offset` as needed)*

### WebSocket Communication

Real-time communication happens over WebSockets.

1.  **Connect:**
    Establish a WebSocket connection to:
    `ws://localhost:8000/ws/YOUR_ACCESS_TOKEN`
    *(Use `wss://` if TLS is configured)*

2.  **Send a message:**
    Send a JSON message over the established WebSocket connection:
    ```json
    {
      "command": "SEND_MESSAGE",
      "payload": {
        "chat_id": 1,
        "text": "Hello from WebSocket!",
        "client_message_id": "unique-client-generated-id-12345"
      }
    }
    ```
    *   `chat_id`: The ID of the chat to send the message to.
    *   `text`: The message content.
    *   `client_message_id`: A unique identifier generated by the client for this message to prevent duplicates on potential retries or parallel sends.

3.  **Mark a message as read:**
    Send a JSON message over the WebSocket:
    ```json
    {
      "command": "READ_MESSAGE",
      "payload": {
        "id": 123
      }
    }
    ```
    *   `id`: The ID of the message that has been read by the current user. The server will notify the sender.

4.  **Receive messages and notifications:**
    Listen for incoming JSON messages on the WebSocket connection. You will receive:
    *   New messages sent by other users in your chats (matching the `MessageResponse` schema).
    *   Notifications when a message you sent has been read (matching the `MessageReadNotification` schema).